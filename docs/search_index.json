[["index.html", "An Overview of Databases and Data Storage Technologies Overview You might need a database if… Learning Goals", " An Overview of Databases and Data Storage Technologies Elise Hellwig 2024-02-12 Overview This workshop provides a broad overview of the various technologies for storing and organizing different collections of data. We will discuss how data structure and data types impact your storage options, when you should use a database, and which platforms you might consider for your research. This workshop is a general lecture with case studies and Q&amp;A (no laptops necessary). This workshop is a prerequisite for DataLab’s Intro to SQL for Querying Databases workshop and part of the Research Computing micro-credential You might need a database if… Your data set has many repeated values in its columns Your data set contains information about many unrelated or loosely related studies You are sharing data with multiple people and everyone seems to have a different version Your data set is so large, your computer freezes when trying to view it You have to keep making the same corrections to your data over and over again Excel keeps converting your columns to the wrong data type You have so many pivot tables You have hundreds (or thousands) of data files you need to share with your collaborators You think PowerQuery is neat but wish people would stop changing the underlying data while you are using it. Learning Goals By the end of this workshop, learners should be able to: Describe different data set structures Compare and contrast different data storage platforms Explain the differences between SQL and noSQL databases Explain the components of an Entity Relationship Diagram (ERD) Define relational keys Identify appropriate data storage solutions based on the structure of a research data set "],["data.html", "1 Data 1.1 Data Types 1.2 Data Structures", " 1 Data Quantities, characters, or symbols on which operations are performed by a computer, considered collectively. Also (in non-technical contexts): information in digital form. - Oxford English Dictionary If you are doing research, chances are you are going to be working with data in some form or another. Even if you do not use the traditional rows and columns people most often associate with “data”, you certainly working with information that has been translated into a form that is more easily shared or stored for later use, aka data. Information becomes data when we give it some sort of structure. That could be the previously mentioned rows and columns, or something more human readable, like the grammar and syntax of natural language. One of the challenges of working with data is figuring out the best way, or at least a good way, to store it. Thankfully, we have mostly left the 20th century’s favorite way of storing data: paper in filing cabinets. Our new methods are definitely less flammable but but also can have a higher barrier to entry. There are also a greater variety in types of data stores, which means you need to make a decision on which one to use. Ultimately, the best way to store your data will depend on the data you want to store, specifically the data type and structure. 1.1 Data Types Your data’s type tells the computer what sorts of operations make sense to do with it. Common data types include integers, decimal or floating point numbers, characters (text), Boolean values (TRUE and FALSE) and date/times. Data type also influences how data is stored. Unlike other characteristics we will discuss later, an individual data point can have a type. Data type is not necessarily inherent to a piece of information, though it is often strongly suggested. For example, you can store the value of 1 as the integer 1, the decimal 1.0, the text “1”, the Boolean TRUE, or the date 1900-01-01 00:00:00. The underlying information is the same (1), but the computer will treat each of these pieces of data differently. It will not allow you to add “1” to another number, and it may have issues combining the integer or decimal 1.0 with text. Text itself can only be stored as characters. 1.2 Data Structures A data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data. Wikipedia Unlike with data types, a single piece of data cannot have a data structure. This is because data structure is about capturing relationships between data points, there isn’t any meaningful information to be gained from the relationship of a data point with itself. We will discuss five of the most common data: tabular/columnar, graph, tree, categorical/relational, and spatial data. In practice, data often exhibits traits from multiple data structures. As mentioned previously, data is information translated into a form to store for later use. The type of information you work with does not dictate the type of data structure you must use. However, some types of information lend themselves to particular data structures over others. When trying to decide what data structure to use to represent information from your research, the key is to focus on what sorts of questions you would like to ask. Each data structure will make some types of questions easier to ask and others harder. If you want to ask disparate types of questions, you may need to represent your data using multiple structures. Because data structure has such a large impact on how you interact with your data, the structure you choose is just as important as the analysis you do afterward. 1.2.1 Columnar/Tabular Tabular or columnar data is made up of rows and columns, collectively referred to as a table. Tables work well when you are working with a class of object where you can summarize the information for each example of that object with the same set of characteristics. By convention, each row represents an observation, and each column a measurement or aspect of that observation. Data scientists refer to the columns of a table by many names, including fields, variables, covariates, measurements, and features. Tabular data is incredibly common in the sciences and many researchers will store at least some of their data in tabular form. In the table below, each row is an observation of a car model released in 1978. Mechanics recorded the make, model and origin of each car and measured the car’s fuel efficiency (mpg), horsepower, weight, and number of cylinders in the engine. ## make model mpg cylinders horsepower weight origin ## 1: chevrolet malibu 20.5 6 95 3155 USA ## 2: chevrolet monte carlo landau 19.2 8 145 3425 USA ## 3: chevrolet chevette 30.0 4 68 2155 USA ## 4: volkswagen rabbit custom diesel 43.1 4 48 1985 Europe ## 5: volvo 264gl 17.0 6 125 3140 Europe ## 6: volkswagen scirocco 31.5 4 71 1990 Europe ## 7: honda civic cvcc 36.1 4 60 1800 Japan ## 8: toyota corona 27.5 4 95 2560 Japan ## 9: toyota celica gt liftback 21.1 4 95 2515 Japan ## 10: honda accord lx 29.5 4 68 2135 Japan Other examples of data sets that lend themselves to a tabular data structure include California almond yields (lb/acre) for farms around the state, climate data over the past 50 years, snow accumulation (inches) for Lake Tahoe, and biomarkers for people participating in a study on a chronic illness. Tabular data lends itself to answering questions about the average value or spread of a particular field over the entire dataset. It can also help investigate trends in a particular variable, or how two covariates relate to each other. In the case of the car fuel efficiency data, we could ask about the relative fuel efficiency of cars from different parts of the world or if there is any relationship between a car’s weight and its horsepower. The tabular data structure also makes sorting observations very easy. 1.2.2 Tree Trees are another commonly used data structure. Tree structured data explicitly capture hierarchical relationships between entities. Trees are made of up nodes (or vertices) which represent entities in the data, and edges which represent relationships between those entities. The number of edges separating an entity from a common root node defines that entity’s place in the hierarchy. When viewing tree structured data on a computer, it often looks very “nested”, like sections and subsections of a document. In fact, tree data is sometimes referred to as document structured data because of this. In general, tree data facilitates asking questions about particular subsets of the data. For example, you might want to know how closely two entities are related, which branches of the tree have the most nodes, or all of the observations that fall under a particular subtree. Family trees are a common example of tree structured data. In family trees, the nodes represent people in the family. In the family tree of the Tutor Dynasty in England below, it is easy to determine things like who had the most wives (Henry VIII), which people shared a generation and who was the last member of the dynasty (James I of England). Questions like the what was the average age at death for the Tudors would be harder to answer. We can also represent the car fuel efficiency data with a tree data structure. This makes it much harder to answer some of the questions mentioned in the previous section. On the other hand, the tree structure makes it very easy to see which car manufacturer produced the greatest number of models in 1978 and how many different models came out of Japan that year. 1.2.3 Graph Graph data is similar to tree data in many ways. It also explicitly captures information about relationships between entities using nodes and edges. However, unlike trees, graph datasets have no inherent center or root node, and there is no implicit sense that part of the graph is “nested” inside another part. Also, the relationships between the vertices can be directional, and the direction does not have to be consistent throughout the graph. Graph structured data tends to be more common in the social sciences and humanities. One of the most ubiquitous examples of a graph is the social network. Transportation data, like roads and flight paths, also lend themselves to the graph structure. In the digital world, we can use graphs to map out the link connections between Wikipedia pages, as seen below with Abraham Lincoln. Graphs make it easy to ask questions about connectivity. For example we might want to know how many flight connections we will need to make between Honolulu, Hawaii and Cairo, Egypt, or how many degrees of separation there are between Abraham Lincoln and Hitler on Wikipedia. We can also ask about which parts of the graph are the most connected and which are the least connected. 1.2.4 Categorical - Relational In categorical data, category membership is the organizing principle of the data structure. Entities can have membership in multiple categories, and relationships are defined between categories instead of the entities themselves. As such, relationships tend to represent complex processes rather than individual entities. 1.2.5 Spatial In spatial data, the organizing principle is location. This can be geographic location (ex latitude/longitude) or relative location on an arbitrary grid (ex. [2, 4]). Data can either be continuous, like a sheet over a landscape, or discrete in space like points on a map. In fact, map making is one of the most common uses of spatial data. However we can alks as questions like de whether points are clustered more closely than we would expect, and whether we can use nearby information to predict values for places where we don’t have data. "],["data-stores.html", "2 Data Stores 2.1 Principles of Data Storage 2.2 Spreadsheets 2.3 Relational Database Management System 2.4 NoSQL Databases", " 2 Data Stores A data store is repository for persistently storing and managing collections of data which include not just repositories like databases, but also simpler store types such as simple files, emails etc. Wikipedia A data store is a repository for storing and managing data. While this workshop covers exclusively digital data stores, for most of human history, data stores were analog. Even today, we still use analog data stores like libraries, museums, and filing cabinets. Data stores have two primary functions. First, they need to facilitate people accessing data (reading) and making changes to the data (writing). Second, they need to preserve this access over a period of time. It is important to remember that not all data stores, even digital ones, are databases. A pile of papers on a desk is definitely not a database, but it could be considered a data store, albeit a bad one. 2.1 Principles of Data Storage When you are trying to decide what type of data storage to use, consider these ideas: When we convert information to data, we encode it in a structure. Different data structures facilitate different research questions. All data stores impose an underlying data structure. The best data storage technology for any research question matches the structure of the data with the structure of the data store. pre { max-height: 300px; overflow-y: auto; } pre[class] { max-height: 100px; } .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } 2.2 Spreadsheets Spreadsheets are one of the most, if not the most, ubiquitous form of (digital) data store. If you have used Microsoft Excel or Google Sheets, you have used a a spreadsheet. In fact spreadsheet applications transformed the use of the personal computer, particularly in business circles. Despite this, a spreadsheet is not a database. Like most modern applications, spreadsheet software have graphical user interfaces, making the barrier to entry very low. Spreadsheet applications also offer some built in analysis tools, so you don’t have to learn a new application to do basic statistics and data visualization. Spreadsheet software also suffers from some drawbacks. They offer limited storage capacity, making it difficult to work with large data sets. Excel and LibreOffice have a maximum row number of a little over 1 million and Google Sheets limits you to 10 million cells. Software operations will also slow down if you get close to their data capacity. This means analyzing large data sets is much more tedious analyzing small ones. Spreadsheets also store data in ways that cause a lot of data duplication and make data entry susceptible to typos. In the spreadsheet visualized below, we have data on the Die Hard franchise. Specifically, we have information about the actors that starred in the series and the movies in which they appeared. library(data.table) dh = fread(&#39;data/die_hard.csv&#39;, header=FALSE) setnames(dh, names(dh), c(&#39;title_id&#39;, &#39;person_id&#39;, &#39;primary_title&#39;, &#39;premiered&#39;, &#39;runtime_minutes&#39;, &#39;genres&#39;, &#39;rating&#39;, &#39;votes&#39;, &#39;name&#39;, &#39;birth&#39;, &#39;death&#39;, &#39;role&#39;, &#39;characters&#39;)) dh ## title_id person_id primary_title premiered runtime_minutes ## 1: tt0095016 nm0000246 Die Hard 1988 132 ## 2: tt0095016 nm0000614 Die Hard 1988 132 ## 3: tt0095016 nm0000889 Die Hard 1988 132 ## 4: tt0095016 nm0001817 Die Hard 1988 132 ## 5: tt0099423 nm0000246 Die Hard 2 1990 124 ## 6: tt0099423 nm0040472 Die Hard 2 1990 124 ## 7: tt0099423 nm0000889 Die Hard 2 1990 124 ## 8: tt0099423 nm0001817 Die Hard 2 1990 124 ## 9: tt0112864 nm0000246 Die Hard with a Vengeance 1995 128 ## 10: tt0112864 nm0000460 Die Hard with a Vengeance 1995 128 ## 11: tt0112864 nm0000168 Die Hard with a Vengeance 1995 128 ## 12: tt0112864 nm0001295 Die Hard with a Vengeance 1995 128 ## 13: tt0337978 nm0000246 Live Free or Die Hard 2007 128 ## 14: tt0337978 nm0519043 Live Free or Die Hard 2007 128 ## 15: tt0337978 nm0648249 Live Free or Die Hard 2007 128 ## 16: tt0337978 nm0702572 Live Free or Die Hard 2007 128 ## 17: tt1606378 nm0000246 A Good Day to Die Hard 2013 98 ## 18: tt1606378 nm2541974 A Good Day to Die Hard 2013 98 ## 19: tt1606378 nm0462407 A Good Day to Die Hard 2013 98 ## 20: tt1606378 nm0935541 A Good Day to Die Hard 2013 98 ## genres rating votes name birth death ## 1: Action,Thriller 8.2 936512 Bruce Willis 1955 NA ## 2: Action,Thriller 8.2 936512 Alan Rickman 1946 2016 ## 3: Action,Thriller 8.2 936512 Bonnie Bedelia 1948 NA ## 4: Action,Thriller 8.2 936512 Reginald VelJohnson 1952 NA ## 5: Action,Thriller 7.1 380561 Bruce Willis 1955 NA ## 6: Action,Thriller 7.1 380561 William Atherton NA NA ## 7: Action,Thriller 7.1 380561 Bonnie Bedelia 1948 NA ## 8: Action,Thriller 7.1 380561 Reginald VelJohnson 1952 NA ## 9: Action,Adventure,Thriller 7.6 405383 Bruce Willis 1955 NA ## 10: Action,Adventure,Thriller 7.6 405383 Jeremy Irons 1948 NA ## 11: Action,Adventure,Thriller 7.6 405383 Samuel L. Jackson 1948 NA ## 12: Action,Adventure,Thriller 7.6 405383 Graham Greene 1952 NA ## 13: Action,Thriller 7.1 418910 Bruce Willis 1955 NA ## 14: Action,Thriller 7.1 418910 Justin Long 1978 NA ## 15: Action,Thriller 7.1 418910 Timothy Olyphant 1968 NA ## 16: Action,Thriller 7.1 418910 Maggie Q 1979 NA ## 17: Action,Thriller 5.2 214179 Bruce Willis 1955 NA ## 18: Action,Thriller 5.2 214179 Jai Courtney 1986 NA ## 19: Action,Thriller 5.2 214179 Sebastian Koch 1962 NA ## 20: Action,Thriller 5.2 214179 Mary Elizabeth Winstead 1984 NA ## role characters ## 1: actor [&quot;&quot;John McClane&quot;&quot;] ## 2: actor [&quot;&quot;Hans Gruber&quot;&quot;] ## 3: actress [&quot;&quot;Holly Gennaro McClane&quot;&quot;] ## 4: actor [&quot;&quot;Sgt. Al Powell&quot;&quot;] ## 5: actor [&quot;&quot;John McClane&quot;&quot;] ## 6: actor [&quot;&quot;Thornberg&quot;&quot;] ## 7: actress [&quot;&quot;Holly McClane&quot;&quot;] ## 8: actor [&quot;&quot;Al Powell&quot;&quot;] ## 9: actor [&quot;&quot;John McClane&quot;&quot;] ## 10: actor [&quot;&quot;Simon&quot;&quot;] ## 11: actor [&quot;&quot;Zeus&quot;&quot;] ## 12: actor [&quot;&quot;Joe Lambert&quot;&quot;] ## 13: actor [&quot;&quot;John McClane&quot;&quot;] ## 14: actor [&quot;&quot;Matt Farrell&quot;&quot;] ## 15: actor [&quot;&quot;Thomas Gabriel&quot;&quot;] ## 16: actress [&quot;&quot;Mai&quot;&quot;] ## 17: actor [&quot;&quot;John McClane&quot;&quot;] ## 18: actor [&quot;&quot;Jack McClane&quot;&quot;] ## 19: actor [&quot;&quot;Komarov&quot;&quot;] ## 20: actress [&quot;&quot;Lucy&quot;&quot;] As you can see, there is a lot of data duplication, meaning our data set takes up much more space on our hard drive than it needs to. Additionally, if we had to change the information about a single movie or actor, we would have to make that change in many different places, and potentially miss one or make a mistake. If we accidentally got Bruce Willis’s birth date wrong, we would have to modify five cells to fix our data, instead of just one. Finally, most spreadsheet applications store their data locally, so unless you are militant about version control outside of the application, it is easy to end up with people working on multiple versions of the data. Google Sheets offers shared access and some version control, but still fails to deliver on storage capacity, and data integrity. 2.2.1 Examples Microsoft Excel Google Sheets Numbers LibreOffice Calc OpenRefine Open Science Framework 2.3 Relational Database Management System Relational Database Management Systems (RDBMSs), or relational databases informally, are one type of database. When people use the word “database”, nine times out of ten they are referring to a relational database. Like spreadsheets, RDBMSs impose a tabular structure on the data they contain. Unlike spreadsheets the structure of that data can be fairly complex. Relational databases are made up of tables that are connected through shared columns, called indexes or keys. Users interact with an RDBMS through the Standardized Query Language (SQL) instead of a graphical user interface. Like python or R, SQL is a programming language, but it is one specifically designed for interacting with relational databases. SQL allows you to standardize your interactions with a database. It allows you to keep a log of the transactions, and makes it easy to ensure everyone is working with the same set of data. However, it has a higher barrier to entry than a graphical user interface like Excel. To learn more about using SQL in practice, check out the Intro to SQL (reader, workshop) and Spatial SQL (reader, workshop) resources. 2.3.1 Relationship keys A relationship key is a column or pair of columns that links two tables. There are two types of relationship keys: primary keys and foreign keys. A primary key is a column that uniquely identifies each row in a particular table. It is generally the first column in the table and is often named “ID”. A foreign key is a column in one table whose values correspond to a primary key in another table. 2.3.2 Entity Relationship Diagrams Since relational databases are not human readable, it can be helpful to have a an visual summary of the database without actually needing to look at the data. That is where Entity Relationship Diagrams (ERDs) come in. ERDs are a standardized way to depict the structure of a relational database. Each box in the diagram is a table, with the table title at the top and the column names listed below it. The column type appears next to each column name. The Primary/foreign key pairs are linked in entity relationship diagrams using connector lines. These lines specify which tables can be joined, and which keys should be used to join them. They also can specify what type of relationship the two tables have. The most common type of table relationship in relational databases is the one-to-many relationship. In this case, one row in table A may be linked to many rows in table B. This is the case for the relationship between the people and crew tables in the IMDB. One-to-one relationships are also fairly common in relational databases. Two tables are one-to-one when one observation in table A only corresponds to one observation in table B. This is the relationship between titles and ratings tables in the IMDB database. As you might guess, there is a third type of relationship: many-to-many. Many-to-many relationships are the sleeping giant of database relationships. They can be very useful, but if you are not careful, they can multiply the size of your data several times over. 2.3.3 Why Use Relational Databases? There are three primary purposes to using RDBMSs as a data store: Reduce data duplication Speed up and standardize accessing and updating the database Ensure data integrity In our Die Hard spreadsheet example, we had 260 cells. However, if we used a relational database to store the data, it only uses 156 cells. That is a 40% reduction in data size. For a multi-gigabyte data set, 40% makes a huge difference. Additionally, we were able to select only some of the columns from each table, meaning we didn’t need to work with ALL of the data just because we wanted to work with some of it. This subsetting is much harder in traditional spreadsheet software. The IMDB database the Die Hard data comes from is massive relative to what you could load in a traditional spreadsheet application. The titles table alone has 10 million observations, and the crew table has over 60 million. Despite this, extracting the Die Hard movie franchise information using an SQL query took about half a second. The SQL query I used is also reproducible. If I want to collaborate on my analysis of Die Hard a colleague, I don’t have to send the Die Hard data set over to my collaborator. Instead I can provide them access to to the IMDB database and my SQL query. If I find problems in the data at a later time, I don’t need to send a whole new data set, and potentially introduce confusion over what data people should be using. All I need to do is update the database, and tell my colleague to rerun their SQL query. No additional computer storage necessary. Store in non-duplicated form, analyze with the duplicates in place. With an RDBMS, even though that data you analyze may have duplicates, you don’t need to modify those duplicate values. All changes to the data can be made to the singleton values in their original tables. For example, if we accidentally left out the second “L” in Bruce Willis’s name when entering the data, we would only need to modify his name once in the “people” table. Then, any time we extract data from the people table, that change will be automatically propagated to our new data. While it may be easy to successfully fix 5 errors, it will be much harder to fix 50, or 5,000. This is especially true if they are scattered throughout your data set and not just in a single column. 2.3.4 RDBMS Software Because of relational databases’ widespread utility, there are many software options to choose from when creating a database. While all of them work off the same basic SQL, each one puts its own particular spin on the language in terms of additional functionality. All of the SQL database software options in the table below have wide community and/or professional support. There are many more RDBMS applications available for more specific use cases (ex. for use with Amazon AWS), but these are the most common and widely supported. Software Ease of Use D ocumentation/ Support Cost License SQLite Easier Extensive documentation and community support $0 Public Domain PostgreSQL Harder Spotty d ocumentation, but with robust community support $0 + cost of hosting Open Source MySQL Easier Large community base, No professional support without paid subscription $0 - Low Cost Partially Open Source Microsoft SQL Server Easier Robust professional and community support High Cost Proprietary Oracle Harder Robust professional and some community support High Cost Proprietary 2.4 NoSQL Databases Not Only SQL, or NoSQL, databases are another type of database. They are primarily defined by what they do not do, namely store data in relational tables, as a RDBMSs would. Instead, NoSQL databases do not necessarily impose external structure on the data they contain. In fact, NoSQL databases can contain data from multiple structures, including documents key-value pairs graphs trees wide column tables Because of this, NoSQL databases are much better at storing tree and graph data, as those data structures do not fit well into relational tables. 2.4.1 Why Use NoSQL Databases? Compatible with multiple data structures Capable of storing vast amounts of data with impressive speed Because NoSQL databases do not have to adhere to the more rigid structure of relational databases, they can store more data and access and modify it more quickly than relational databases. This is particularly important when working with textual data, which can easily take up many terabytes of storage. 2.4.2 Example Software Not every NoSQL database supports every data structure. Some support multiple structures while others specialize in one. Software Data Structure Cost MongoDB Tree/Document Couchbase Tree/Document Cassandra Column family Redis key-value Neo4J Graph ArangoDB Tree/Document, graph, key-value "],["choosing-the-right-data-store.html", "3 Choosing the Right Data Store 3.1 CAP Theorem 3.2 Polyglot Persistance", " 3 Choosing the Right Data Store 3.1 CAP Theorem 3.2 Polyglot Persistance "],["assessment.html", "4 Assessment", " 4 Assessment "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
