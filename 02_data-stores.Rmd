# Data Stores

> A data store is repository for persistently storing and managing collections
> of data which include not just repositories like databases, but also simpler
> store types such as simple files, emails etc.
>
> Wikipedia


Once you have decided on a data structure, the next decision to make is what
type of data store to use for data storage. A data store is a repository for
storing and managing data. While this workshop covers exclusively digital data
stores, for most of human history, data stores were analog. Even today, we still
use analog data stores like libraries, museums, and filing cabinets. Data stores
have two primary functions. First, they need to facilitate people accessing the
data (reading) and making changes to it (writing). Second, they need to preserve
this access over a period of time.

Regardless of your data's structure you have two general options for how to
store your data digitally: in flat files or in a database. 

Probably the most common type of data store is a flat file. A *flat file* is
stand alone file on your computer that is not linked to data elsewhere. You can
store tabular data in .xlsx and .csv files, tree data in .xml and .json files,
graph data in .GML and .DOT, and spatial data in .GeoJSON and .GeoTIFF files.
All of these file types have applications you can use to access and modify your
data, or you can load the data into a programming environment like R or python.
In addition, many of these file types, like csvs and jsons are human readable,
meaning you do *not* need special software to access or modify the data they
contain.


In comparison, a *database* is an organized collection of data that is linked or
related in some way. Users can interact with a database through specialized
software called a database management system, often abbreviated DBMS.
Databases are not ge, human readable. Databases have several
key characteristics that differentiate them from other data stores like flat
files.

1.  **Structure** - Databases can store data with structures ranging from low to
    high complexity.

2.  **Scalability** - Databases can store vastly more information more than flat
    files. Additionally, databases support substantial computing upgrades, which
    means you can maintain performance as your data set grows. Even if you 
    upgrade your computer, you still can't have more than 1 million rows in 
    Excel.

3.  **Access** - Databases allow multiple people to interact with data at the
    same time without locking people out or introducing conflicts. They also 
    provide fine-grained controls on who can access, modify, and delete data.

Specific types of databases have other differentiating features, like data
integrity constraints, flexible data structure support. Databases also have
several drawbacks:

  * Data in databases is not human readable without specialized software. This 
  is different from some file types including csv, xml, DOT, and GML. However,
  binary files, like xlsx and docx, require specialized software as well.
  
  * Database software generally has a steeper learning curve than graphical user
  interfaces. You may need to learn a specialized language to interact with the
  data in your database.
  
  * There may be cost associated, either for the database software or for
  hardware needed to run the software. 
  
  * Databases require some level of administration. Someone will need to be in
  charge of adding data to the database, determining who has access to what,
  and fixing things when they break.

If you are running into any of the following issues, a database may be
the solution to your problems.

  * Your data set has many repeated values 
  
  * Your data set contains information about many unrelated or loosely related
  studies
  
  * You are sharing data with multiple people and everyone seems to have a
  different version
  
  * Your data set is so large, your computer slows down or freezes when trying 
  to view it
  
  * You have to keep making the same corrections to your data over and over
  again
  
  * Excel keeps converting your columns to the wrong data type
  
  * You have so many pivot tables
  
  * You have hundreds (or thousands) of data files you need to share with your
  collaborators
  
  * You think PowerQuery is neat but wish people would stop changing the
  underlying data while you are using it.
  
  * You have a hard time finding and extracting the information you need to
  answer a particular research question
  
  * Processing your data requires you to spend a lot of time moving data between
  spreadsheets by hand.

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 300px;
}
```

```{css, echo=FALSE}
.scroll-300 {
  max-height: 300px;
  overflow-y: auto;
  background-color: inherit;
}
```

## Spreadsheets

<!--
why not excel:
Excel file is proprietary (owned by a company)
also can have csv file, aka ASCII delimited file (not sure I will go into this)

Differentiate between the file and the software

file is the data store?
-->

Spreadsheets, a type of flat file, are a common form of digital data store. If
you have used Microsoft Excel or Google Sheets, you have used a spreadsheet.
Like some databases, spreadsheets impose a tabular data structure on the data
they store. Despite this, a spreadsheet is not a database. Like most modern
software, spreadsheet applications have graphical user interfaces, making the
barrier to entry very low. Spreadsheet software also offers some built in
analysis tools, so you don't have to learn a new application to do basic
statistics and data visualization.

Spreadsheet software also suffers from some drawbacks. They offer limited
storage capacity, making it difficult to work with large data sets. Excel and
LibreOffice have a maximum row number of a little over 1 million and Google
Sheets limits you to 10 million cells. Software operations will also slow down
if you get close to their data capacity. This means analyzing large data sets
is much more tedious than analyzing small ones.

Spreadsheets also store data in ways that cause a lot of data duplication and
make data entry susceptible to typos. In the spreadsheet visualized below, we
have data on the Die Hard movie franchise. Specifically, we have information
about the actors that starred in the series and the movies in which they
appeared.

```{r, echo=FALSE}
# class.output="scroll-300",

library(data.table)
library(kableExtra)

dh = fread('data/die_hard.csv', header=FALSE)
setnames(dh, names(dh),
         c('title_id', 'person_id', 'title', 'premiered', 
           'runtime', 'genres', 'rating', 'votes', 'name', 'birth',
            'death', 'role', 'characters'))

dh = dh[,.(title_id, person_id, title, name, characters, premiered,
           runtime, genres, rating, votes, birth, death, role)]

kbl(dh) |>
  scroll_box(width = "100%", height = "400px")

```

Looking at the last three columns, there is a lot of data duplication, meaning
our data set takes up more space on our hard drive than it needs to.
Additionally, if we have to change the information about a single movie or
actor, we would have to make that change in many different places, and
potentially miss one or make a mistake. If we accidentally left out an "l" in
Bruce Willis's last name, we would have to modify five cells to fix our data.

<!--maybe put something in here about different text versions of the same
information, ex. yes, Yes, Y, and YES
-->

Finally, most spreadsheet applications store their data locally, so unless you
are very careful about version control outside the application, it is easy to
end up with people working on different versions of the data. Google Sheets
offers shared access and some version control, but still fails to deliver on
storage capacity, and data integrity.

### Examples

-   Microsoft Excel
-   Google Sheets
-   Numbers
-   LibreOffice Calc
-   OpenRefine
-   Open Science Framework

## Relational Database Management System

<!--
designed for very fast querying for large datasets (ex price on an amazon 
website)

Linked connections of tables in a structured/specific way

join table (put two tables together), 

nothing should ever appear twice, numbers are always faster than text

ex student changes their address, you only have to change it in one place

-->
Relational Database Management Systems (RDBMSs), or relational databases, are
one type of database. When people use the word "database", nine times out of ten
they are referring to a relational database. Like spreadsheets, RDBMSs impose a
tabular structure on the data they contain. A basic relational database is a
collection of connected tables. However, they can be more complex. The tables in
the database are linked by shared columns, called keys.

Users often interact with an RDBMS through the Structured Query Language (SQL)
instead of a graphical user interface, though there are exceptions. SQL is a
programming language, but it is one specifically designed for interacting with
relational databases. SQL standardizes your interactions with a database, and
makes them reproducible. This means it is much easier to ensure everyone is
working with the same set of data. Working with SQL is a skill, and will take
some time to acquire. However, because of SQL's narrow scope, is easier to learn
than a more complex programming language like python or R.

To learn about using SQL in practice, check out DataLab's Intro to SQL
([reader](https://ucdavisdatalab.github.io/workshop_intro_to_sql/), workshop)
and Spatial SQL ([reader](https://github.com/ucdavisdatalab/Spatial_SQL),
workshop) resources.

### Relationship keys

A relationship key is a column or pair of columns that links two tables. One
example of a relationship key you may use is a student or employee ID number.
You can use that number to link information about you in one part of the
University to another part of the University. This is what allows you to pay for
meal plans via the Student Accounting department and you can use your meal plan
through Dining Services. The student ID number ensures that the money you spend
gets credited to the correct account.

There are two types of relationship keys: primary keys and foreign keys. A
primary key, sometimes called an index, is a column that uniquely identifies
each row in a particular table. It is generally the first column in the table. A
foreign key is a column in one table whose values correspond to a primary key in
another table. Student ID would be a primary key in a table that lists all of
the students at the university with some basic information about them.  It would
be a foreign key in a table that lists all food and beverage sales at a
particular on campus eatery.

### Entity Relationship Diagrams

Since relational databases may not have a graphical interface, it can be helpful
to have a visual summary of a database before interacting with it. That
is where the Entity Relationship Diagram (ERD) comes in. ERDs are a
standardized way to depict the structure of a relational database. Each box in
the diagram represents a table, with the table title at the top and the column
names listed below it. The column data type appears next to each column name.


Connector lines link primary/foreign key pairs. These lines specify which
tables can be combined, and which keys should be used to combine them. The
connector lines also specify what type of relationship between the two tables.

![](img/imdb_ERD.png)

The most common type of table relationship in relational databases is the
one-to-many relationship. In this case, one row in table A may be linked to
many rows in table B. This is the case for the relationship between the people
and crew tables in the IMDB. One-to-one relationships are also fairly common in
relational databases. Two tables are one-to-one when one observation in table A
only corresponds to one observation in table B. This is the relationship
between titles and ratings tables in the IMDB database.

As you might guess, there is a third type of relationship: many-to-many.
Many-to-many relationships are the sleeping giant of database relationships.
They can be very useful, but if you are not careful, they can multiply the size
of your data several times over. Library book checkout transactions are one
example of a many to many relationship. A single patron can check out multiple
books in a single transaction, and multiple patrons can check out a book.

### Why Use Relational Databases?

There are three primary reasons to use a RDBMS as a data store:

1.  Reduce data duplication

2.  Speed up and standardize accessing and updating the database

3.  Ensure data integrity

In our Die Hard spreadsheet example, we had 260 cells. However, in a relational
database, storing that same data only requires 156 cells. That is a 40%
reduction in data size. For a multi-gigabyte data set, 40% makes a huge
difference. Additionally, much of that information was stored as numbers
instead of text, which makes its size on your hard drive even smaller. Finally,
we selected a subset of columns from each table, which means we didn't need to
work with ALL of the data just because we wanted to work with some of it.
Subsetting like this is much harder in traditional spreadsheet software.

The source database of our Die Hard data, IMDB, is massive relative to
spreadsheet software capabilities. The titles table alone has 10 million
observations, and the crew table has over 60 million. Despite this, extracting
the Die Hard movie franchise information using an SQL query took about half a
second.

The SQL query used to extract the Die Hard data is also reproducible. If I want
to collaborate with a colleague on my analysis of Die Hard, I don't have to
send the data set to my collaborator. Instead I can provide them access to to
the IMDB database and my SQL query. If I find problems in the data at a later
time, I don't need to send a whole new data set, which could introduce
confusion about which data to use. All I need to do is update the database, and
tell my colleague to rerun their SQL query. No additional computer storage
necessary.

With an RDBMS, even though the data you analyze may have duplicates, you don't
need to modify each duplicate value, in the case that one requires a
correction. All changes to the data can be made to the singleton values in
their original tables. Correcting Bruce Willis's misspelled last name only
requires fixing his name once in the "people" table. Then, any time you extract
data from the database table, that change will automatically propagate to the
new data. While it may be easy to successfully fix 5 errors, it will be much
harder to fix 50, or 5,000. This is especially true if they are scattered
throughout your data set and not just in a single column.

### RDBMS Software

Because of relational databases' widespread utility, there are many software
options to choose from when creating a database. While all of them work off the
same basic SQL, each one puts its own particular spin on the language in terms
of additional functionality. All of the SQL database software options in the
table below have wide community and/or professional support. There are many
more RDBMS applications available for more specific use cases (ex. for use with
Amazon AWS), but these are the most common and widely supported. All of them
provide some level of support for spatial data. However, that level of support
varies, so if you have specific requirements, it's best to do additional
research before making a decision.

+------------+----------+-----------------------+------------+--------------+
| Software   | Ease of  | Documentation/        | Cost       | License      |
|            | Use      | Support               |            |              |
+============+==========+=======================+============+==============+
| SQLite     | Easier   | Extensive             | \$0        | Public       |
|            |          | documentation and     |            | Domain       |
|            |          | community support     |            |              |
+------------+----------+-----------------------+------------+--------------+
| PostgreSQL | Harder   | Spotty documentation, | \$0 + cost | Open Source  |
|            |          | but with robust       | of hosting |              |
|            |          | community support     |            |              |
+------------+----------+-----------------------+------------+--------------+
| MySQL      | Easier   | Large community base, | \$0 - Low  | Partially    |
|            |          | No professional       | Cost       | Open Source  |
|            |          | support without paid  |            |              |
|            |          | subscription          |            |              |
+------------+----------+-----------------------+------------+--------------+
| Microsoft  | Easier   | Robust professional   | High Cost  | Proprietary  |
| SQL Server |          | and community support |            |              |
+------------+----------+-----------------------+------------+--------------+
| Oracle     | Harder   | Robust professional   | High Cost  | Proprietary  |
|            |          | and some community    |            |              |
|            |          | support               |            |              |
+------------+----------+-----------------------+------------+--------------+

## NoSQL Databases

Not Only SQL, or NoSQL, databases are another type of database. They are
primarily defined by what they do not do, namely store data in relational
tables, as a RDBMSs would. Instead, NoSQL databases do not necessarily impose
external structure on the data they contain. In fact, NoSQL databases can
contain data from multiple structures, including

-   documents
-   key-value pairs
-   graphs
-   trees
-   wide column tables

This makes NoSQL databases are much better at storing tree and graph data, as
those data structures do not fit well into relational tables.

### Why Use NoSQL Databases?

1.  Compatible with multiple data non-tabular structures

2.  Capable of storing vast amounts of data with impressive speed

3.  Adding more computing power is easier

Because NoSQL databases do not have to adhere to the more rigid structure of
relational databases, they can store more data and access and modify it more
quickly than relational databases. This is particularly important when working
with textual data, which can easily take up many terabytes of storage. It is
also generally easier to upgrade NoSQL databases, which is important when you
are working on the edge of what is possible data storage-wise.

### Example Software

Not every NoSQL database supports every data structure. Some support multiple
structures while others specialize in one. Unlike RDBMSs, all of the most
common NoSQL software is open source, though the MongoDB license is slightly
more restrictive than most open source licenses. Because of this they are also
low cost to implement, though you can always pay for additional features and
support. Similar to RDBMSs, all the most common NoSQL database software
provides some support of spatial data. However, that support is limited to
vector data and the functionality available varies fairly widely.

+-------------------+-------------------------------+-------------------+
| Software          | Data Structure                | Spatial Support   |
+===================+===============================+===================+
| MongoDB           | Tree/Document                 | vector            |
+-------------------+-------------------------------+-------------------+
| Couchbase         | Tree/Document                 | vector            |
+-------------------+-------------------------------+-------------------+
| Cassandra         | Column family                 | vector (DataStax) |
+-------------------+-------------------------------+-------------------+
| Redis             | key-value                     | point only        |
+-------------------+-------------------------------+-------------------+
| Neo4J             | Graph                         | vector            |
+-------------------+-------------------------------+-------------------+
| ArangoDB          | Tree/Document, graph,         | vector            |
|                   | key-value                     |                   |
+-------------------+-------------------------------+-------------------+
