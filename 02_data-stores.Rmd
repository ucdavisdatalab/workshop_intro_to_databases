# Data Stores

> A data store is repository for persistently storing and managing collections
> of data which include not just repositories like databases, but also simpler
> store types such as simple files, emails etc.
>
> Wikipedia

A data store is a repository for storing and managing data. While this workshop
covers exclusively digital data stores, for most of human history, data stores
were analog. Even today, we still use analog data stores like libraries,
museums, and filing cabinets. Data stores have two primary functions. First,
they need to facilitate people accessing data (reading) and making changes to
the data (writing). Second, they need to preserve this access over a period of
time.

It is important to remember that not all data stores, even digital ones, are
databases. A pile of papers on a desk is definitely not a database, but it could
be considered a data store, albeit a bad one.

## Principles of Data Storage

When you are trying to decide what type of data storage to use, consider these
ideas:

<!--
1. All data has an inherent structure-->

1.  When we convert information to data, we encode it in a structure.

2.  Different data structures facilitate different research questions.

3.  All data stores impose an underlying data structure.

4.  The best data storage technology for any research question matches the
    structure of the data with the structure of the data store.

## Data Store Vocabulary

There are a few concepts that will be useful when describing types of data
stores and comparing their functionality.

### Transaction

A transaction is a unit of work within a database. Any time you change a
database, either by adding, removing or modifiying data, you are completing a
transaction. Extracting data from a database is also a transaction.

### Normalization

Data normalization is the process of organizing data in a database in a way
that reduces the database's size. It the organization structure also protects
against typos and other data quality issues from sneaking in. In general, data
normalization will break one group of data into multiple groups.

### Join

While it is much easier to store normalized data, most data analysis will
require you to work with data in a non-normalized form. A data join reverses
the normalization process. It takes multiple groups of data and combines them
into one.


## Types of Data Stores

## Spreadsheets

<!--
why not excel:
Excel file is proprietary (owned by a company)
also can have csv file, aka ASCII delimited file (not sure I will go into this)

Differentiate between the file and the software

file is the data store?
-->

Spreadsheets are one of the most, if not the most, ubiquitous form of (digital)
data store. If you have used Microsoft Excel or Google Sheets, you have used a
a spreadsheet. In fact spreadsheet applications transformed the use of the
personal computer, particularly in business circles. Despite this, a
spreadsheet is not a database. Like most modern applications, spreadsheet
software have graphical user interfaces, making the barrier to entry very low.
Spreadsheet applications also offer some built in analysis tools, so you don't
have to learn a new application to do basic statistics and data visualization.

Spreadsheet software also suffers from some drawbacks. They offer limited
storage capacity, making it difficult to work with large data sets. Excel and
LibreOffice have a maximum row number of a little over 1 million and Google
Sheets limits you to 10 million cells. Software operations will also slow 
down if you get close to their data capacity. This means analyzing large
data sets is much more tedious analyzing small ones.

Spreadsheets also store data in ways that
cause a lot of data duplication and make data entry susceptible to typos. In 
the spreadsheet visualized below, we have data on the Die Hard franchise. 
Specifically, we have information about the actors that starred in the series 
and the movies in which they appeared. 

As you can see, there is a lot of data duplication, meaning our data set takes
up much more space on our hard drive than it needs to. Additionally, if we had 
to change the information about a single movie or actor, we would have to make 
that change in many different places, and potentially miss one or make a mistake.
If we accidentally got Bruce Willis's birth date wrong, we would have to modify
five cells to fix our data, instead of just one. 

<!--Put something in here about different text versions of the same information,
ex. yes, Yes, Y, and YES
-->

Finally, most spreadsheet applications store their data locally, so unless you
are militant about version control outside of the application, it is easy to
end up with people working on multiple versions of the data. Google Sheets
offers shared access and some version control, but still fails to deliver on
storage capacity, and data integrity.

### Examples

-   Microsoft Excel
-   Google Sheets
-   Numbers
-   LibreOffice Calc
-   OpenRefine
-   Open Science Framework

## Relational Database Management System

<!--
designed for very fast querying for large datasets (ex price on an amazon 
website)

Linked connections of tables in a structured/specific way

join table (put two tables together), 

nothing should ever appear twice, numbers are always faster than text

ex student changes their address, you only have to change it in one place

-->

Relational Database Management Systems (RDBMSs), or relational databases
informally, are one type of database. When people use the word "database", nine
times out of ten they are referring to a relational database. Like
spreadsheets, RDBMSs impose a tabular structure on the data they contain. Unlike
spreadsheets the structure of that data can be fairly complex. Relational
databases are made up of tables that are connected through shared columns,
called indexes or keys.

Users interact with an RDBMS through the Standardized Query Language (SQL)
instead of a graphical user interface. Like python or R, SQL is a programming
language, but it is one specifically designed for interacting with relational
databases. SQL allows you to standardize your interactions with a database. It
allows you to keep a log of the transactions, and makes it easy to ensure
everyone is working with the same set of data. However, it has a higher barrier
to entry than a graphical user interface like Excel.

To learn more about using SQL in practice, check out the Intro to SQL 
([reader][sql_reader], workshop) and Spatial SQL ([reader][spat_reader], 
workshop) resources. 

[sql_reader]: https://ucdavisdatalab.github.io/workshop_intro_to_sql/
[spat_reader]: https://github.com/ucdavisdatalab/Spatial_SQL

### Relationship keys

A relationship key is a column or pair of columns that links two tables. There
are two types of relationship keys: primary keys and foreign keys. A primary
key is a column that uniquely identifies each row in a particular table. It is
generally the first column in the table and is often named "ID". A foreign key
is a column in one table whose values correspond to a primary key in another
table.

### Entity Relationship Diagrams

Since relational databases are not human readable, it can be helpful to have a
an visual summary of the database without actually needing to look at the data.
That is where Entity Relationship Diagrams (ERDs) come in. ERDs are a
standardized way to depict the structure of a relational database. Each box in
the diagram is a table, with the table title at the top and the column names
listed below it. The column type appears next to each column name. The

Primary/foreign key pairs are linked in entity relationship diagrams using
connector lines. These lines specify which tables can be joined, and which keys
should be used to join them. They also can specify what type of relationship
the two tables have.

The most common type of table relationship in relational databases is the
one-to-many relationship. In this case, one row in table A may be linked to many
rows in table B. This is the case for the relationship between the people and
crew tables in the IMDB. One-to-one relationships are also fairly common in
relational databases. Two tables are one-to-one when one observation in table A
only corresponds to one observation in table B. This is the relationship between
titles and ratings tables in the IMDB database.

As you might guess, there is a third type of relationship: many-to-many.
Many-to-many relationships are the sleeping giant of database relationships.
They can be very useful, but if you are not careful, they can multiply the size
of your data several times over.

### Why Use Relational Databases?

There are three primary purposes to using RDBMSs as a data store:

  1. Reduce data duplication
  
  2. Speed up and standardize accessing and updating the database
  
  3. Ensure data integrity

In our Die Hard spreadsheet example, we had 260 cells. However, if we used a
relational database to store the data, it only uses 156 cells. That is a 40% 
reduction in data size. For a multi-gigabyte data set, 40% makes a huge
difference. Additionally, we were able to select only some of the columns from
each table, meaning we didn't need to work with ALL of the data just because 
we wanted to work with some of it. This subsetting is much harder in traditional
spreadsheet software.

The IMDB database the Die Hard data comes from is massive relative to what you
could load in a traditional spreadsheet application. The titles table alone has
10 million observations, and the crew table has over 60 million. Despite this,
extracting the Die Hard movie franchise information using an SQL query took
about half a second.

The SQL query I used is also reproducible. If I want to collaborate on my
analysis of Die Hard a colleague, I don't have to send the Die Hard data set 
over to my collaborator. Instead I can provide them access to to the IMDB 
database and my SQL query. If I find problems in the data at a later
time, I don't need to send a whole new data set, and potentially introduce 
confusion over what data people should be using. All I need to do is update the
database, and tell my colleague to rerun their SQL query. No additional computer
storage necessary.

Store in non-duplicated form, analyze with the duplicates in place. 

With an RDBMS, even though that data you analyze may have duplicates, you don't
need to modify those duplicate values. All changes to the data can be made to
the singleton values in their original tables. For example, if we accidentally
left out the second "L" in Bruce Willis's name when entering the data, we would
only need to modify his name once in the "people" table. Then, any time we
extract data from the people table, that change will be automatically propagated
to our new data. While it may be easy to successfully fix 5 errors, it will be
much harder to fix 50, or 5,000. This is especially true if they are scattered
throughout your data set and not just in a single column.


### Pros and Cons of RDBMS

| Pros                                            | Cons                                   |
|-------------------------------------------|------------------------------------|
| Supports ACID Transactions                      | Only vertical scaling                  |
| Supports normalization and joins                | Joins mean loss of speed               |
| Captures relationships with defined constraints | Requires an administrator of some sort |
| Data integrity through normalization and types  | Data is not human readable             |
| Unlimited indexing                              | Pre-defined data model                 |
| Robust query language (SQL)                     |                                        |
| Lots of software options (some free)            |                                        |

### Examples

-   Microsoft SQL Server
-   PostgreSQL
-   MySQL
-   SQLite
-   Amazon Redshift

## NoSQL Databases

Not Only SQL, or NoSQL, databases are another type of database. They are
primarily defined by what they do not do, namely store data in relational
tables, as a RDBMSs would. Instead, NoSQL databases do not necessarily impose 
external structure on the data they contain. In fact, NoSQL databases can contain data
from multiple structures, including

  * documents
  * key-value pairs
  * graphs
  * trees
  * wide column tables

Because of this, NoSQL databases are much better at storing tree and graph data,
as those data structures do not fit well into relational tables. 

### Transactions are BASE

The NoSQL databases do not have built-in assumptions about structure, they
cannot guarantee strictly ACID transactions. However, unlike spreadsheets, they
do follow a less rigorous set of rules abbreviated as BASE. This less stringent
set of rules requires much less computing overhead and makes scaling easier.

**Basically Available** - Users can interact with the database concurrently.
transactions are not isolated like in relational databases, so you will not be
locked out part of the database.

**Soft state** - Transactions do not have to maintain consistency. There can be
intermediate steps that are not compliant. Additionally, internal replicates of
the data may not always be identical.

**Eventually consistent** - While the database may not always be consistent, it
will get there eventually.

### Pros and Cons

| Pros                                   | Cons                                   |
|----------------------------------------|----------------------------------------|
| Works with semi- and unstructured data | BASE (not ACID)                        |
| Horizontal scaling                     | Data is not normalized                 |
| Data structure is not predetermined    | Limited support for joins and indexing |
| Very fast                              | Slow indexing                          |
| Supports different kinds of fields     | Weak SQL                               |
| High availability                      | No built in data integrity support     |

### Examples

  * MongoDB
  * DocumentDB
  * Cassandra
  * Coachbase
  * HBase
  * Redis
  * Neo4J
  * Lucene
  * ArangoDB


